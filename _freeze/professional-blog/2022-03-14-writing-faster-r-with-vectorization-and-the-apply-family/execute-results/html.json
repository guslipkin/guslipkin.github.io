{
  "hash": "e83366897f73e072dd956c8d1b51fd07",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Writing Faster R With Vectorization and the Apply Family\"\ndescription: \"Learning when and how to use for loops, the apply family, and vectorization to write fast code in R\"\nauthor: \"Gus Lipkin\"\ndate: \"2022/03/14\"\ncategories:\n  - R\n  - \"R: apply\"\nformat:\n  html:\n    toc: true\n---\n\n\n[*Link to the Medium post*](https://guslipkin.medium.com/writing-faster-r-with-vectorization-and-the-apply-family-ff6078a2583a)\n\n# Intro\n\nOne of my favorite things about R is that there are a lot of ways to do the same thing. Of course, this means that some ways are better than others depending on the use case. `for` loops, the `apply` family, and vectorization are all common ways to write code for large amounts of data in R, but it can be tricky to know when to use each one and how to use them.\n\nI’ve divided this post into how to use each method in R and then give a few examples of when you might want to use each one. I close everything out with a short benchmark demonstration to compare the three.\n\n----\n\n# What is a(n)...\n## `for` loop\n\n*If you’re familiar with programming, you can probably skip this section.*\n\nA for loop lets you run the same code a specified number of times. The structure generally follows `for(x in y)` where `x` represents an item in `y`. If we think about a shopping basket with some apples, bananas, and carrots, we could write `for(food in basket)` and food would represent each item in our basket. It would be apples the first time, bananas the second time, and carrots the third time. We could also write it as `for(food in 1:length(basket))` where `1:length(basket)` is a vector of numbers that counts the items in your basket. Rather than food representing an item in your basket, it represents an index in the vector. In this example, apples are at index 1, bananas at 2, and carrots at 3. `for` loops are also very flexible and can be used on many data types such as vectors, data.frames, and matrices.\n\nLet’s say you have a `data.frame` called `basket` that has three columns. It has the `Food` column with the name of the food, the `PricePerUnit` which has the unit cost for each food, and `Quantity` which has the number of units of each food in your basket. It looks like this:\n\n| Food    | PricePerUnit | Quantity |\n|---------|--------------|----------|\n| Apples  | 0.99         | 12       |\n| Bananas | 0.19         | 6        |\n| Carrots | 0.49         | 2        |\n\nAnd it can be recreated with this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasket <- data.frame(\"Food\" = c(\"Apples\", \"Bananas\", \"Carrots\"),\n                     \"PricePerUnit\" = c(.99, .19, .49),\n                     \"Quantity\" = c(12, 6, 2))\n```\n:::\n\n\nIf we wanted to get the total cost of everything in our basket, we could iterate over each row multiplying the `PricePerUnit` and `Quantity` and adding those to our running totals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create the total\ntotal <- 0\n# loop over the data.frame and add the running total\nfor(row in 1:nrow(basket))\n  total <- total + (basket$PricePerUnit[row] * basket$Quantity[row])\ntotal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14\n```\n\n\n:::\n:::\n\n\n## `apply` family\n\nThe `apply` family is part of base R and very similar to a for loop. Rather than running a set number of times, an `apply` runs a function on each item in a `data.frame`, `list`, `vector`, or other object that can be applied to. While there are six different functions in the `apply` family, I’m only going to talk about the three most common; `apply`, `lapply`, and `sapply`.\n\nThe biggest differences between the three is the types of input that they accept and their output types. `apply` takes in a `data.frame` or matrix and has three function arguments. The first argument, `x`, is the object we’re passing to it. The second argument is a number, either 1 or 2 or `c(1, 2)`, that says if we want the function applied to rows, columns, or both rows and columns, respectively. The last argument is the function call. `sapply` and `lapply` are the same, except they don’t have the second argument because they take either a vector or list which don’t have multiple dimensions. Generally speaking, the `apply` family will return a vector, list, or array of some kind.\n\nIf we go back to the shopping basket example, we can calculate the total with an `apply` function. Our first argument is the `basket`, the second is a `1` because we want to `apply` to every row, and the last is the function call. We can create the function in the `apply` call or we can create it earlier and then call it here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# multiply each PricePerUnit and Quantity and store the resulting vector\nperItemTotal <- apply(basket, 1, function(bskt) {\n  as.numeric(bskt[\"PricePerUnit\"]) * as.numeric(bskt[\"Quantity\"])\n})\n# sum all values in the perItemTotal\nsum(perItemTotal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14\n```\n\n\n:::\n:::\n\n\n**A quick note on function calls in the apply family:**\n\nIf a function call only has one argument, they can be done in three ways.\n1. `sapply(X, function(x) { ... })` if function is not predefined\n2. `sapply(X, function)` if function is predefined\n3. `sapply(X, function(x))` if function is predefined\n\nOption two is most common for built-in functions such as `sum` or `as.numeric`, but can be used with any function.\n\n## Vector Operations\n\nVector operations are not a function like the `apply` family or a `for` loop, but rather a feature of the R language. Instead of operating on a vector one item at a time, R is able to do an operation on the entire vector in one line of code. Back to the basket example again, we know that the per item total is the `PricePerUnit` and `Quantity` multiplied together, and then we get the grand total by summing all of those values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# take the sum of multiplying PerPriceUnit and Quantity to get total cost\nsum(basket$PricePerUnit * basket$Quantity)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14\n```\n\n\n:::\n:::\n\n\n----\n\n# When should I use a(n)...\n\nThese examples are not exhaustive and you may find some cases where one is better than the others even where it seems like it might not be.\n\n## `for` loop\n\n`for` loops in R should be a last resort. They are much slower compared to the apply family and vectorized code. They may be helpful when each iteration relies on the iteration before it, although then you might want to look into a recursive function if possible. You might find a `for` loop useful if you need to run the same block of code multiple times or iterate over elements of an object in a non-standard way such as every other item. Any code that can be written with an `apply` function or a vector operation can be written in a `for` loop.\n\n## `apply` family\nThe `apply` family should be used when you want to operate on each element of an object, but treat them individually. This might present as a list with vectors of differing lengths for each item or if you want a specific type of output. Any vector operation can be written as an `apply` statement, but not all `for` loops can be converted.\n\n## Vector Operations\n\nVector operations are the gold standard. They are fast and can be used in many cases, but not all. Most common use cases will be on vectors or columns of a `data.frame`. Many base functions such as `sum` and `as.numeric` are already vectorized. Many but not all `for` loops and `apply` functions can be written as vectorized operations.\n\n----\n\n# Benchmarks\n\n## Building the input\n\nRather than use the simple shopping basket example from before, I’ve written a small function that takes a `data.frame` of red, green, and blue values and adds a new column with the corresponding hex code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a vector of the possible hex code values (0-9 and A-F)\nhex <- c(0:9, LETTERS[1:6])\n\n# set the seed\nset.seed(2022)\n# pick the number of rows\nrows <- 10^4\n# create a data.frame of rgb values\ndf <- data.frame(\"red\" = sample(0:255, rows, replace = TRUE), \n                 \"green\" = sample(0:255, rows, replace = TRUE),\n                 \"blue\" = sample(0:255, rows, replace = TRUE))\n```\n:::\n\n\nAnd the resulting data should look like this:\n\n| red | green | blue |\n|-----|-------|------|\n| 227 | 18    | 84   |\n| 178 | 245   | 26   |\n| 205 | 219   | 176  |\n| 54  | 236   | 205  |\n| 74  | 252   | 67   |\n| 195 | 116   | 122  |\n\nWe’ve also created a vector of values that can go in a hex code with numbers 0–9 and letters A-F.\n\n## Creating the conversion function\n\nI used [this website](https://www.developintelligence.com/blog/2017/02/rgb-to-hex-understanding-the-major-web-color-codes/) for the math behind my functions. In essence, you divide each number by `16` and round down and the resulting number corresponds to a position in hex. You then take the remainder of the division and get the hex value that that number corresponds to. If our value is `227`, then our first hex code is `227/16` would round down to `14` and the remainder would be `3`. Because vectors in R start at position `1`, we add one to both for `15` and `4`. The corresponding values in hex are `E` and `3` and so the hex pair for `227` is `E3`.\n\n## Implementing the conversion function\n\n### In a `for` loop\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# iterate over each row in df\nfor(r in 1:nrow(df)) {\n  # get a value for each position in the hex code\n  # first pair\n  h1 <- hex[floor(df$red[r] / 16) + 1]\n  h2 <- hex[df$red[r] %% 16 + 1]\n  \n  # second pair\n  h3 <- hex[floor(df$green[r] / 16) + 1]\n  h4 <- hex[df$green[r] %% 16 + 1]\n\n  # third pair\n  h5 <- hex[floor(df$blue[r] / 16) + 1]\n  h6 <- hex[df$blue[r] %% 16 + 1]\n  \n  # assemble the values using `paste0` and assign it to the `hex` column for \n  # the corresponding row\n  df$hex[r] <- paste0(\"#\", h1, h2, h3, h4, h5, h6)\n}\n```\n:::\n\n\n### In an `apply` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df[, c(\"red\", \"green\", \"blue\")]\n# create the rgbToHex function that takes a named vector and returns a hex code\nrgbToHex <- function(x) {\n  # get a value for each position in the hex code\n  # first pair\n  h1 <- hex[floor(x[\"red\"] / 16) + 1]\n  h2 <- hex[x[\"red\"] %% 16 + 1]\n  \n  # second pair\n  h3 <- hex[floor(x[\"green\"] / 16) + 1]\n  h4 <- hex[x[\"green\"] %% 16 + 1]\n\n  # third pair\n  h5 <- hex[floor(x[\"blue\"] / 16) + 1]\n  h6 <- hex[x[\"blue\"] %% 16 + 1]\n  \n  # assemble and return the hex code\n  paste0(\"#\", h1, h2, h3, h4, h5, h6)\n}\n# call `rgbToHex` and apply it to each row in df\ndf$hex <- apply(df, 1, rgbToHex)\n```\n:::\n\n\n### In a vectorized function\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# paste the calculated hex codes into the new `hex` column in df\ndf$hex <- paste0(\"#\", \n                 hex[floor(df$red / 16) + 1],\n                 hex[df$red %% 16 + 1],\n                 hex[floor(df$green / 16) + 1],\n                 hex[df$green %% 16 + 1],\n                 hex[floor(df$blue / 16) + 1],\n                 hex[df$blue %% 16 + 1])\n```\n:::\n\n\n### The results\n\n| red | green | blue | hex     |\n|-----|-------|------|---------|\n| 227 | 18    | 84   | #E31254 |\n| 178 | 245   | 26   | #B2F51A |\n| 205 | 219   | 176  | #CDDBB0 |\n| 54  | 236   | 205  | #36ECCD |\n| 74  | 252   | 67   | #4AFC43 |\n| 195 | 116   | 122  | #C3747A |\n\n\n## Running the benchmark\n\nI’ve simplified the `for` loop and `apply` implementations a little bit to better match the vectorized function. This way we have a better comparison between the three. Your benchmark results may be a little different because it is a little dependent on your computer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrows <- 10^4\nhex <- c(0:9, LETTERS[1:6])\n\nset.seed(2022)\ndt <- data.frame(\"red\" = sample(0:255, rows, replace = TRUE), \n                 \"green\" = sample(0:255, rows, replace = TRUE),\n                 \"blue\" = sample(0:255, rows, replace = TRUE))\n\nrbenchmark::benchmark(\n  \"for loop\" = {\n    df <- dt\n    for (r in 1:nrow(df)) {\n      df$hexFor[r] <- paste0(\"#\", \n                             hex[floor(df$red[r] / 16) + 1],\n                             hex[df$red[r] %% 16 + 1],\n                             hex[floor(df$green[r] / 16) + 1],\n                             hex[df$green[r] %% 16 + 1],\n                             hex[floor(df$blue[r] / 16) + 1],\n                             hex[df$blue[r] %% 16 + 1]\n                             )\n    }\n  },\n  \"apply\" = {\n    df <- dt\n    rgbToHex <- function(x) {\n      paste0(\"#\",\n             hex[floor(x[\"red\"] / 16) + 1],\n             hex[x[\"red\"] %% 16 + 1],\n             hex[floor(x[\"green\"] / 16) + 1],\n             hex[x[\"green\"] %% 16 + 1],\n             hex[floor(x[\"blue\"] / 16) + 1],\n             hex[x[\"blue\"] %% 16 + 1]\n             )\n    }\n    df$hexApply <- apply(df, 1, rgbToHex)\n  },\n  \"vector\" = {\n    df <- dt\n    df$hexVector <- paste0(\"#\",\n                           hex[floor(df$red / 16) + 1],\n                           hex[df$red %% 16 + 1],\n                           hex[floor(df$green / 16) + 1],\n                           hex[df$green %% 16 + 1],\n                           hex[floor(df$blue / 16) + 1],\n                           hex[df$blue %% 16 + 1]\n                           )\n  },\n  replications = 10, order = \"relative\"\n) -> benches\n```\n:::\n\n\n| test    | replications | elapsed | relative | user.self | sys.self | user.child | sys.child |\n|---------|--------------|---------|----------|-----------|----------|------------|-----------|\n| vector  | 10           | 0.026   | 1.000    | 0.025     | 0.000    | 0          | 0         |\n| apply   | 10           | 0.536   | 20.615   | 0.530     | 0.006    | 0          | 0         |\n| forloop | 10           | 1.569   | 60.346   | 1.252     | 0.317    | 0          | 0         |\n\nThe important column is relative as that shows a comparison between the three with the quickest function given a value of 1. Using an `apply` function took roughly 20x longer and a `for` loop roughly 60x longer than using a vectorized function.\n\n\n![](../assets/post-assets/2022-03-14-writing-faster-r-with-vectorization-and-the-apply-family/sonic.jpeg){alt=\"A hand drawn Sonic the Hedgehog saying “Gotta go fast”\"}\n\n----\n\nAll code used in this article is available [here](https://gist.github.com/guslipkin/f21dc766bac769ef69c220fe476306b4#file-basket-csv?file=vectorise.rmd). If you want to see more from me, check out [my GitHub](https://github.com/guslipkin) or [guslipkin.github.io](https://guslipkin.github.io). If you want to hear from me, I'm also on Twitter [@guslipkin](https://twitter.com/GusLipkin).\n\n\n<center><em>Gus Lipkin is a Data Scientist, Business Analyst, and occasional bike mechanic</em></center>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}